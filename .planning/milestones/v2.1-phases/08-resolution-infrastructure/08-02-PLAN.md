---
phase: 08-resolution-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - src/tool_errors.py
  - src/tools_write.py
  - tests/test_e2e_integration.py
autonomous: true
requirements:
  - ERG-03
  - ERG-04
  - ERG-05

must_haves:
  truths:
    - "Agent can call write_answers with pair_id and answer_text only (no xpath, no mode) and the answer is written correctly"
    - "Server re-extracts compact structure to resolve pair_id to xpath when xpath is not provided"
    - "When both xpath and pair_id are provided, server cross-checks and warns on mismatch but does not block the write"
    - "Cross-check warnings appear in the response dict under a 'warnings' key (only when non-empty)"
    - "Mode defaults to replace_content when answer_text is provided and mode is omitted"
    - "insertion_xml path still requires explicit xpath and mode (backward compatible)"
    - "All 281+ existing tests pass without modification"
  artifacts:
    - path: "src/tool_errors.py"
      provides: "Resolution-aware payload building"
      contains: "resolve_pair_ids"
    - path: "src/tools_write.py"
      provides: "Warnings in response, file_bytes passthrough"
      contains: "warnings"
    - path: "tests/test_e2e_integration.py"
      provides: "E2E tests for pair_id-only writes"
      contains: "pair_id_only"
  key_links:
    - from: "src/tool_errors.py"
      to: "src/pair_id_resolver.py"
      via: "import resolve_pair_ids, cross_check_xpaths"
      pattern: "from src\\.pair_id_resolver import"
    - from: "src/tools_write.py"
      to: "src/tool_errors.py"
      via: "build_answer_payloads now accepts file_bytes"
      pattern: "build_answer_payloads\\(answer_dicts, ft, raw\\)"
---

<objective>
Wire pair_id resolution into the write_answers pipeline so agents can omit xpath and mode.

Purpose: This is the integration plan that connects the resolver module (Plan 01) into the
actual write path. After this plan, an agent can call write_answers with just
`{pair_id: "T1-R2-C2", answer_text: "Acme Corp"}` and the server resolves the xpath,
defaults the mode, and writes the answer correctly.

Output: Updated tool_errors.py with resolution logic, updated tools_write.py with
file_bytes passthrough and warnings, E2E tests proving the full flow works.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-resolution-infrastructure/08-RESEARCH.md
@.planning/phases/08-resolution-infrastructure/08-01-SUMMARY.md
@src/tool_errors.py
@src/tools_write.py
@src/pair_id_resolver.py
@src/models.py
@tests/test_e2e_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate resolution into tool_errors.py and tools_write.py</name>
  <files>src/tool_errors.py, src/tools_write.py</files>
  <action>
**In `src/tool_errors.py`:**

1. Change `build_answer_payloads` signature to accept optional `file_bytes`:
   `def build_answer_payloads(answer_dicts: list[dict], ft: FileType, file_bytes: bytes | None = None) -> tuple[list[AnswerPayload], list[str]]`
   Note the return type changes from `list[AnswerPayload]` to `tuple[list[AnswerPayload], list[str]]` -- the second element is the list of cross-check warnings.

2. Update `build_answer_payloads` to pass `file_bytes` to `_build_word_payloads` and `_build_relaxed_payloads`.

3. Update `_build_word_payloads` signature to accept `file_bytes: bytes | None = None`:
   - Before the existing required-field check, determine which answers need resolution:
     ```python
     needs_resolution = any(
         not a.get("xpath") and _is_provided(a.get("answer_text"))
         for a in answer_dicts
     )
     needs_cross_check = any(
         a.get("xpath") and a.get("pair_id")
         for a in answer_dicts
     )
     ```
   - If `needs_resolution or needs_cross_check` and `file_bytes is not None`:
     ```python
     from src.pair_id_resolver import resolve_pair_ids, cross_check_xpaths
     pair_ids = [a["pair_id"] for a in answer_dicts if a.get("pair_id")]
     resolved = resolve_pair_ids(file_bytes, FileType.WORD, pair_ids)
     warnings = cross_check_xpaths(answer_dicts, resolved)
     ```
   - For answers missing xpath: fill from `resolved` dict. If pair_id not found in resolved, raise ValueError: `"Answer '{pair_id}' (index {i}): No xpath provided and pair_id could not be resolved. Re-extract with extract_structure_compact to get current IDs."`
   - For answers missing mode when answer_text is provided: default to `InsertionMode.REPLACE_CONTENT`
   - For cross-checked answers: if mismatch, use the resolved xpath (pair_id is authority), keep the warning
   - Update the required-field check: skip "xpath" and "mode" from `_WORD_REQUIRED` when `answer_text` is provided. The cleanest way is to check per-answer: if answer has `answer_text`, xpath and mode are optional; if answer has `insertion_xml`, xpath and mode are required.

4. Update `_build_relaxed_payloads` similarly -- accept `file_bytes`, resolve when needed. The relaxed path already defaults mode to replace_content. For xpath resolution on Excel/PDF: resolve using the appropriate indexer. Add cross-check.

5. Both `_build_word_payloads` and `_build_relaxed_payloads` return `tuple[list[AnswerPayload], list[str]]` now.

6. Update the USAGE example for write_answers to show the simplified form:
   ```python
   "write_answers": (
       'write_answers(file_path="form.docx", answers=[{"pair_id": "T1-R2-C2", '
       '"answer_text": "Acme Corp"}])'
   ),
   ```

**In `src/tools_write.py`:**

1. Update the `write_answers` function to pass `raw` (file_bytes) to `build_answer_payloads`:
   ```python
   payloads, warnings = build_answer_payloads(answer_dicts, ft, raw)
   ```

2. Add warnings to the response dict (only when non-empty):
   ```python
   response = {"file_bytes_b64": base64.b64encode(result_bytes).decode()}
   if warnings:
       response["warnings"] = warnings
   return response
   ```
   Same for the file_path response path.

3. Update the write_answers docstring to document that xpath and mode are optional when answer_text is provided, and that the response may include a "warnings" key.

**IMPORTANT constraints:**
- tool_errors.py is already 342 lines. The changes add ~30 lines of resolution logic but save ~5 lines by simplifying the required-field check. Stay aware of file size. If it grows beyond 370 lines, extract the resolution integration into a helper function in pair_id_resolver.py instead.
- insertion_xml answers MUST still require explicit xpath and mode. Only answer_text answers get optional xpath/mode.
- When file_bytes is None (shouldn't happen in practice but defensive), skip resolution and require explicit xpath.
  </action>
  <verify>
`cd /home/sarturko/vibe-legal-form-filler && python -m pytest tests/ -v` -- all existing tests pass.
`wc -l src/tool_errors.py` -- monitor file size.
  </verify>
  <done>
build_answer_payloads accepts file_bytes and returns (payloads, warnings).
write_answers passes file_bytes through and includes warnings in response.
insertion_xml path unchanged. answer_text path resolves xpath and defaults mode.
All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E tests for pair_id-only write_answers</name>
  <files>tests/test_e2e_integration.py</files>
  <action>
Add tests to the existing `tests/test_e2e_integration.py` file (or create a new test file
`tests/test_resolution.py` if e2e_integration.py would exceed 200 lines).

Tests to add:

1. **test_write_answers_pair_id_only_word**: Call write_answers with a Word fixture, providing only `pair_id` and `answer_text` (no xpath, no mode). Verify the answer is written correctly by reading the output document and checking the target cell text matches.

2. **test_write_answers_pair_id_only_defaults_mode**: Call write_answers with `pair_id` and `answer_text` only. Verify the mode defaults to `replace_content` (existing cell content is replaced, not appended to).

3. **test_write_answers_cross_check_warning**: Call write_answers with `pair_id`, `answer_text`, AND a deliberately wrong `xpath`. Verify:
   - The write succeeds (pair_id is authority, resolved xpath is used)
   - The response contains a `warnings` key with a mismatch message
   - The answer appears at the CORRECT location (resolved from pair_id, not the agent's wrong xpath)

4. **test_write_answers_pair_id_not_found**: Call write_answers with a `pair_id` that doesn't exist in the document. Verify a clear ValueError is raised mentioning the pair_id and suggesting re-extraction.

5. **test_write_answers_insertion_xml_still_requires_xpath**: Call write_answers with `insertion_xml` but NO xpath. Verify a ValueError is raised requiring xpath for the insertion_xml path.

6. **test_write_answers_pair_id_only_excel**: Call write_answers with an Excel fixture, providing only `pair_id` and `answer_text`. Verify the answer is written correctly.

Use existing fixtures: tests/fixtures/table_questionnaire.docx, tests/fixtures/vendor_assessment.xlsx.
Use `file_path` input mode where possible (simpler test setup).
For verifying written content, use the verify_output tool or re-extract and check.
  </action>
  <verify>
`cd /home/sarturko/vibe-legal-form-filler && python -m pytest tests/test_e2e_integration.py -v -k "pair_id"` -- all new pair_id tests pass.
`cd /home/sarturko/vibe-legal-form-filler && python -m pytest tests/ -v` -- all tests pass (new + existing).
  </verify>
  <done>
6 new tests prove pair_id-only writes work for Word and Excel.
Cross-check warnings are returned in response.
insertion_xml path still requires xpath.
All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- all tests pass (281 existing + ~12 new)
2. Write a minimal pair_id-only answer and verify output:
   ```python
   python -c "
   from src.tools_write import write_answers
   result = write_answers(
       file_path='tests/fixtures/table_questionnaire.docx',
       answers=[{'pair_id': 'T1-R2-C2', 'answer_text': 'Test Corp'}],
       output_file_path='/tmp/test_resolution.docx',
   )
   print(result)
   "
   ```
   Should succeed and write file without error.
3. Verify backward compatibility: run existing e2e tests that use full payloads (xpath + mode + insertion_xml).
</verification>

<success_criteria>
- Agent can call write_answers with pair_id + answer_text only -- answer written correctly
- Mode defaults to replace_content when omitted with answer_text
- Cross-check warnings appear in response when xpath and pair_id disagree
- insertion_xml path still requires explicit xpath and mode
- All 281+ existing tests pass without modification
- 6+ new E2E tests prove the resolution pipeline works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/08-resolution-infrastructure/08-02-SUMMARY.md`
</output>
