---
phase: 02-protocol-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/http_transport.py, tests/test_http_protocol.py]
autonomous: true
requirements: [TRANS-03, TRANS-04, TRANS-05, TRANS-06]

must_haves:
  truths:
    - "POST /mcp with valid JSON-RPC initialize request returns 200 with SSE response"
    - "POST /mcp with invalid mcp-protocol-version header returns 400 with JSON-RPC error body listing supported versions"
    - "POST /mcp with invalid Origin header returns 403"
    - "POST /wrong returns 404 with JSON-RPC error body (not plain text)"
    - "PUT /mcp returns 405 with JSON-RPC error body"
    - "POST /mcp with wrong Accept header returns 406 with JSON-RPC error body"
    - "All 207 existing unit tests still pass"
  artifacts:
    - path: "src/http_transport.py"
      provides: "Custom JSON-RPC 404 exception handler attached to Starlette app"
      contains: "_json_rpc_404_handler"
    - path: "tests/test_http_protocol.py"
      provides: "Protocol compliance tests for TRANS-03/04/05/06"
      min_lines: 80
  key_links:
    - from: "src/http_transport.py"
      to: "mcp.streamable_http_app()"
      via: "exception_handlers[404] attached to Starlette app"
      pattern: "exception_handlers\\[404\\]"
    - from: "tests/test_http_protocol.py"
      to: "src/http_transport.py"
      via: "imports _json_rpc_404_handler and builds test app"
      pattern: "_json_rpc_404_handler"
---

<objective>
Add custom JSON-RPC 404 handler to the HTTP transport and write protocol compliance tests verifying all MCP HTTP requirements (JSON-RPC 2.0, header validation, error responses, DNS rebinding protection).

Purpose: The MCP Python SDK already handles TRANS-03/04/05 and most of TRANS-06 internally. The one gap is Starlette's default plain-text 404 for wrong paths. This plan closes that gap and adds regression tests confirming all SDK-provided protocol behavior.

Output: Modified http_transport.py with 404 handler, new test_http_protocol.py with full protocol compliance coverage.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-protocol-implementation/02-RESEARCH.md
@.planning/phases/01-transport-setup/01-01-SUMMARY.md
@src/http_transport.py
@src/mcp_app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add custom JSON-RPC 404 handler to http_transport.py</name>
  <files>src/http_transport.py</files>
  <action>
Add a custom Starlette exception handler for 404 that returns a JSON-RPC error body instead of plain text. This is the ONLY code change needed for protocol compliance — the SDK handles everything else.

1. Add imports at the top of http_transport.py:
   - `from starlette.requests import Request`
   - `from starlette.responses import JSONResponse`

2. Add a new async function `_json_rpc_404_handler(request: Request, exc: Exception) -> JSONResponse` that returns:
   ```python
   JSONResponse(
       {"jsonrpc": "2.0", "id": "server-error", "error": {"code": -32600, "message": "Not Found"}},
       status_code=404,
   )
   ```
   Include a docstring explaining: Starlette's default 404 returns plain text. MCP protocol compliance (TRANS-06) requires JSON-RPC error bodies on all error responses.

3. In `_run_http_async()`, after `starlette_app = mcp.streamable_http_app()`, add:
   ```python
   starlette_app.exception_handlers[404] = _json_rpc_404_handler
   ```

Do NOT modify any other behavior. The function signature, port check, uvicorn config, and shutdown timeout remain unchanged. The file should grow from 88 lines to ~103 lines — well under the 200-line limit.
  </action>
  <verify>
Run: `python -c "from src.http_transport import _json_rpc_404_handler; print('Handler importable')"` — should print "Handler importable".
Run: `pytest tests/ -x -q` — all 207 existing tests still pass.
  </verify>
  <done>
`_json_rpc_404_handler` exists in http_transport.py and is attached to the Starlette app in `_run_http_async()`. All existing tests pass. File is under 200 lines.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write protocol compliance tests for TRANS-03/04/05/06</name>
  <files>tests/test_http_protocol.py</files>
  <action>
Create `tests/test_http_protocol.py` with tests verifying all MCP HTTP protocol requirements. Use Starlette's TestClient (no real server startup needed — that's Phase 3).

CRITICAL PITFALLS (from research):
- TestClient MUST use `with` context manager for lifespan (session manager requires it)
- TestClient MUST include `headers={"Host": "localhost:8000"}` (default "testserver" triggers 421)
- Post-init requests MUST include `Mcp-Session-Id` header
- Initialize requests skip protocol version header validation (version is in body params)

Create a pytest fixture that builds the test app and provides an initialized client:

```python
import pytest
from starlette.testclient import TestClient
from src.mcp_app import mcp
import src.tools_extract  # noqa: F401 — trigger tool registration
import src.tools_write    # noqa: F401
from src.http_transport import _json_rpc_404_handler

INIT_BODY = {
    "jsonrpc": "2.0",
    "method": "initialize",
    "id": 1,
    "params": {
        "protocolVersion": "2025-03-26",
        "capabilities": {},
        "clientInfo": {"name": "test", "version": "1.0"},
    },
}

MCP_HEADERS = {
    "Content-Type": "application/json",
    "Accept": "application/json, text/event-stream",
}

@pytest.fixture
def mcp_client():
    """TestClient with lifespan, correct Host, and completed init handshake."""
    app = mcp.streamable_http_app()
    app.exception_handlers[404] = _json_rpc_404_handler
    with TestClient(app, raise_server_exceptions=False, headers={"Host": "localhost:8000"}) as client:
        resp = client.post("/mcp", json=INIT_BODY, headers=MCP_HEADERS)
        assert resp.status_code == 200
        session_id = resp.headers.get("mcp-session-id")
        client._session_id = session_id  # stash for tests
        yield client
```

Write these test functions (one per requirement scenario):

**TRANS-03: JSON-RPC 2.0 POST requests**
- `test_initialize_returns_200()` — POST /mcp with valid initialize body returns 200
- `test_tools_list_returns_tools()` — POST /mcp with tools/list (using session ID) returns registered tools

**TRANS-04: Protocol version validation**
- `test_bad_protocol_version_returns_400()` — POST /mcp with `mcp-protocol-version: 9999-99-99` header on a tools/list request returns 400 with JSON-RPC error body containing "supported" in the message
- `test_missing_protocol_version_accepted()` — POST /mcp without protocol version header succeeds (SDK defaults to 2025-03-26)

**TRANS-05: Origin validation (DNS rebinding protection)**
- `test_invalid_origin_returns_403()` — POST /mcp with `Origin: http://evil.com` returns 403
- `test_valid_origin_accepted()` — POST /mcp with `Origin: http://localhost:8000` returns 200
- `test_missing_origin_accepted()` — POST /mcp without Origin header returns 200 (same-origin requests)

**TRANS-06: HTTP error responses**
- `test_wrong_path_returns_json_rpc_404()` — POST /wrong returns 404 with JSON body containing "jsonrpc" and "error" keys
- `test_wrong_method_returns_405()` — PUT /mcp returns 405
- `test_wrong_accept_returns_406()` — POST /mcp with `Accept: text/html` returns 406

For each test, assert both the HTTP status code AND the response body format (JSON-RPC error structure where applicable). For the 404 test specifically, verify `Content-Type` is `application/json` (not `text/plain`).

For tests that need the session ID (tools/list, protocol version), include `Mcp-Session-Id` from the fixture. For tests on the initialize request itself (Origin, basic 200), no session ID is needed.

Note: The Origin validation test with invalid origin should use a FRESH TestClient (not the fixture) because the invalid origin will fail on the initialize request itself. Same for the wrong path, wrong method, and wrong accept tests — these can use the fixture since the error occurs before session checks, OR use a fresh client.
  </action>
  <verify>
Run: `pytest tests/test_http_protocol.py -v` — all protocol tests pass.
Run: `pytest tests/ -x -q` — all 207 existing tests PLUS new protocol tests pass.
  </verify>
  <done>
tests/test_http_protocol.py exists with tests covering all four requirements (TRANS-03, TRANS-04, TRANS-05, TRANS-06). Each test verifies both HTTP status code and response body format. All tests pass alongside existing tests.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -x -q` — all existing tests (207) plus new protocol tests pass
2. `python -c "from src.http_transport import _json_rpc_404_handler"` — handler is importable
3. `wc -l src/http_transport.py` — under 200 lines
4. Manual check: test_http_protocol.py covers all 4 requirement IDs (TRANS-03/04/05/06)
</verification>

<success_criteria>
- Custom JSON-RPC 404 handler in http_transport.py closes the only SDK gap
- Protocol compliance tests verify all SDK-provided behavior as regression guards
- All existing tests continue passing (no regressions)
- File sizes within 200-line project limit
</success_criteria>

<output>
After completion, create `.planning/phases/02-protocol-implementation/02-01-SUMMARY.md`
</output>
