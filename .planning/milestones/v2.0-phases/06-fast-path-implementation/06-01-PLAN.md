---
phase: 06-fast-path-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/handlers/word_writer.py
  - tests/test_word.py
autonomous: true
requirements:
  - FAST-01
  - FAST-02
  - FAST-03

must_haves:
  truths:
    - "write_answers with answer_text (no insertion_xml) inserts the answer text into the output document"
    - "Inserted text inherits font family, font size, bold, italic, and color from the target element"
    - "replace_content mode works with answer_text"
    - "append mode works with answer_text"
    - "replace_placeholder mode works with answer_text"
    - "Existing insertion_xml callers continue working unchanged"
  artifacts:
    - path: "src/handlers/word_writer.py"
      provides: "_build_insertion_xml_for_answer_text helper, updated _apply_answer routing"
      contains: "_build_insertion_xml_for_answer_text"
    - path: "tests/test_word.py"
      provides: "Tests for all three modes with answer_text"
      contains: "answer_text"
  key_links:
    - from: "src/handlers/word_writer.py"
      to: "src/xml_formatting.py"
      via: "import extract_formatting_from_element, build_run_xml through xml_utils barrel"
      pattern: "extract_formatting_from_element|build_run_xml"
    - from: "src/handlers/word_writer.py (_apply_answer)"
      to: "src/handlers/word_writer.py (_build_insertion_xml_for_answer_text)"
      via: "routing check on answer.answer_text"
      pattern: "answer\\.answer_text is not None"
---

<objective>
Implement the fast path so that `write_answers` builds insertion OOXML internally when `answer_text` is provided, eliminating the per-answer `build_insertion_xml` MCP round-trip.

Purpose: This is the core performance win of v2.0 -- a 30-answer form no longer needs 30 extra tool calls.
Output: Updated word_writer.py with routing logic, tests proving all three modes work with answer_text.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-fast-path-implementation/06-RESEARCH.md
@src/handlers/word_writer.py
@src/xml_utils.py
@src/xml_formatting.py
@tests/test_word.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fast path helper and routing in word_writer.py</name>
  <files>src/handlers/word_writer.py</files>
  <action>
Add the fast path to word_writer.py. Two changes needed:

1. **Add import** — extend the existing `from src.xml_utils import ...` line to also import `extract_formatting_from_element` and `build_run_xml`.

2. **Add helper function** — place `_build_insertion_xml_for_answer_text(target, answer_text)` BEFORE `_apply_answer()` (around line 142). Implementation:
   ```python
   def _build_insertion_xml_for_answer_text(
       target: etree._Element, answer_text: str
   ) -> str:
       """Build insertion OOXML from plain text, inheriting formatting from target.

       This is the fast path: the server builds the same XML that the
       build_insertion_xml MCP tool would produce, without an extra round-trip.
       """
       formatting = extract_formatting_from_element(target)
       return build_run_xml(answer_text, formatting)
   ```

3. **Update `_apply_answer()` routing** — after resolving `target`, add a routing block before the mode switch:
   ```python
   # Fast path: build insertion XML from answer_text when provided
   if answer.answer_text is not None and answer.answer_text.strip():
       insertion_xml = _build_insertion_xml_for_answer_text(
           target, answer.answer_text
       )
   else:
       insertion_xml = answer.insertion_xml
   ```
   Then change the three mode calls to use the local `insertion_xml` variable instead of `answer.insertion_xml`.

**Critical:** Use `answer.answer_text is not None and answer.answer_text.strip()` for the routing check (inline, do NOT import the private `_is_provided` from tool_errors). The batch validation in tool_errors.py already guarantees exactly-one-of semantics, so this check is a safety net.

**Line budget:** word_writer.py is 181 lines. This adds ~15 lines (helper + routing). Target ~196 lines, under the 200-line limit.
  </action>
  <verify>
Run `python -c "from src.handlers.word_writer import _build_insertion_xml_for_answer_text; print('import OK')"` to confirm the function exists.
Run `wc -l src/handlers/word_writer.py` to confirm under 200 lines.
Run `pytest tests/test_word.py -x -q` to confirm all existing tests still pass (no regressions).
  </verify>
  <done>
`_build_insertion_xml_for_answer_text` exists and is importable. `_apply_answer` routes to it when `answer_text` is provided. word_writer.py is under 200 lines. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for all three modes with answer_text</name>
  <files>tests/test_word.py</files>
  <action>
Add a new test class `TestWriteAnswersWithAnswerText` to tests/test_word.py. Tests call `write_answers` (the public handler API from `src.handlers.word`) with `AnswerPayload` using `answer_text` instead of `insertion_xml`.

**Test 1: replace_content with answer_text** — use the `table_docx` fixture. Build an AnswerPayload with `answer_text="Acme Corporation"`, `insertion_xml=None`, `mode=InsertionMode.REPLACE_CONTENT`, and a valid XPath for an empty cell. Call `write_answers`. Parse the output .docx, find the target cell, assert the text content is "Acme Corporation".

**Test 2: append with answer_text** — use the `table_docx` fixture. Build an AnswerPayload with `answer_text=" (Amended)"`, `insertion_xml=None`, `mode=InsertionMode.APPEND`, and a valid XPath for a cell with existing text. Call `write_answers`. Parse output, assert the target element now contains the original text plus " (Amended)".

**Test 3: replace_placeholder with answer_text** — use the `placeholder_docx` fixture. Build an AnswerPayload with `answer_text="Our security policy includes..."`, `insertion_xml=None`, `mode=InsertionMode.REPLACE_PLACEHOLDER`, and a valid XPath for the paragraph containing "[Enter here]". Call `write_answers`. Parse output, assert "[Enter here]" is gone and the answer text is present.

**Test 4: formatting inheritance** (FAST-02) — use the `table_docx` fixture. Pick a target element that has bold formatting or a specific font. Call `write_answers` with `answer_text`. Parse the output and check that the inserted `<w:r>` contains `<w:rPr>` with the formatting properties from the target element (e.g., same font family, font size).

**Test 5: insertion_xml still works (regression)** — call `write_answers` with a standard `insertion_xml` payload (no `answer_text`). Assert result is identical to before. This confirms backward compatibility.

For extracting XPaths: use `extract_structure_compact` or `validate_locations` on the fixture to get valid XPaths, or hardcode known XPaths from the fixture files (the existing tests already know the fixture structure).

To parse output .docx for verification: unzip the result bytes, parse `word/document.xml`, use XPath to find the target element and check its text.
  </action>
  <verify>
Run `pytest tests/test_word.py -x -q` — all tests pass, including the new ones.
Run `pytest tests/ -x -q` — full test suite passes (no regressions in other test files).
  </verify>
  <done>
Five new tests cover: replace_content, append, replace_placeholder with answer_text; formatting inheritance verification; insertion_xml backward compatibility. All tests pass. Full test suite has zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -x -q` — full test suite passes
2. `wc -l src/handlers/word_writer.py` — under 200 lines
3. New tests confirm all three modes work with answer_text
4. Existing insertion_xml-based tests still pass (backward compatibility)
</verification>

<success_criteria>
- write_answers accepts answer_text (no insertion_xml) and produces a valid .docx with the answer inserted
- All three modes (replace_content, append, replace_placeholder) work with answer_text
- Inserted text inherits formatting from the target element
- Existing callers using insertion_xml are unaffected
- word_writer.py stays under 200 lines
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-fast-path-implementation/06-01-SUMMARY.md`
</output>
