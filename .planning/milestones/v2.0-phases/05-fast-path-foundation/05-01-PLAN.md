---
phase: 05-fast-path-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models.py
  - src/xml_formatting.py
  - src/xml_utils.py
  - tests/test_xml_utils.py
autonomous: true
requirements:
  - FAST-05
  - COMPAT-01

must_haves:
  truths:
    - "AnswerPayload accepts answer_text as an optional field alongside insertion_xml"
    - "AnswerPayload defaults both insertion_xml and answer_text to None"
    - "extract_formatting_from_element() returns the same dict as extract_formatting() for the same element"
    - "extract_formatting() delegates to extract_formatting_from_element() internally"
    - "All 234 existing tests pass without modification"
  artifacts:
    - path: "src/models.py"
      provides: "AnswerPayload with optional answer_text and insertion_xml fields"
      contains: "answer_text: str | None = None"
    - path: "src/xml_formatting.py"
      provides: "extract_formatting_from_element public function"
      exports: ["extract_formatting_from_element", "extract_formatting"]
    - path: "src/xml_utils.py"
      provides: "Re-export of extract_formatting_from_element"
      contains: "extract_formatting_from_element"
  key_links:
    - from: "src/xml_formatting.py"
      to: "extract_formatting_from_element"
      via: "extract_formatting delegates to it"
      pattern: "return extract_formatting_from_element"
    - from: "src/xml_utils.py"
      to: "src/xml_formatting.py"
      via: "barrel re-export"
      pattern: "from src.xml_formatting import.*extract_formatting_from_element"
---

<objective>
Add the `answer_text` field to `AnswerPayload`, create `extract_formatting_from_element()` as a public function, and verify backward compatibility.

Purpose: Establish the API contract that Phase 6 will implement (fast path) and expose the formatting extraction function it will need. No write-path changes yet.
Output: Updated model in models.py, new public function in xml_formatting.py, re-export in xml_utils.py, tests confirming parity.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-fast-path-foundation/05-CONTEXT.md
@.planning/phases/05-fast-path-foundation/05-RESEARCH.md
@src/models.py
@src/xml_formatting.py
@src/xml_utils.py
@tests/test_xml_utils.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AnswerPayload model and create extract_formatting_from_element</name>
  <files>
    src/models.py
    src/xml_formatting.py
    src/xml_utils.py
  </files>
  <action>
**models.py changes:**
1. On `AnswerPayload` class (line 126), change `insertion_xml: str` to `insertion_xml: str | None = None`. Update the inline comment to: `# pre-built XML (Word) or plain value (Excel/PDF)`
2. Add a new field `answer_text: str | None = None` with comment `# plain text answer (fast path, Phase 6)`
3. Field order should be: pair_id, xpath, insertion_xml, answer_text, mode, confidence

**xml_formatting.py changes:**
1. Add `extract_formatting_from_element(elem: etree._Element) -> dict` as a new public function BEFORE the existing `extract_formatting()`. It takes a pre-parsed lxml element (not a string) and returns the same formatting dict. Implementation: call `_find_run_properties(elem)`, then `_extract_font_properties`, `_extract_size_and_color`, `_extract_style_properties` -- identical to the current body of `extract_formatting()` but without the `_parse_element_xml` step. Include a docstring explaining this is for callers that already have a parsed element (Phase 6 fast path).
2. Refactor `extract_formatting()` to delegate: parse the string with `_parse_element_xml`, then call `extract_formatting_from_element(elem)`. This ensures one code path for formatting extraction (no logic drift).

**xml_utils.py changes:**
1. Add `extract_formatting_from_element` to the `from src.xml_formatting import (...)` block.
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all 234 tests must pass. Then run `python -c "from src.xml_utils import extract_formatting_from_element; print('import ok')"` to confirm the re-export works. Then run `python -c "from src.models import AnswerPayload; a = AnswerPayload(pair_id='q1', xpath='/x', insertion_xml='<w:r/>', mode='replace_content'); print(a.answer_text)"` and confirm it prints `None`.
  </verify>
  <done>
AnswerPayload has both insertion_xml and answer_text as Optional[str] = None. extract_formatting_from_element exists and is re-exported through xml_utils. extract_formatting delegates to it. All 234 existing tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for extract_formatting_from_element parity</name>
  <files>
    tests/test_xml_utils.py
  </files>
  <action>
Add a new test class `TestExtractFormattingFromElement` to tests/test_xml_utils.py with these tests:

1. `test_extract_formatting_from_element_matches_string_version` -- Parse an OOXML element string with font, size, bold, and color formatting using `_parse_element_xml` (import from xml_formatting). Call both `extract_formatting(string)` and `extract_formatting_from_element(parsed_elem)`. Assert the dicts are identical.

2. `test_extract_formatting_from_element_empty_rpr` -- Pass an element with no `<w:rPr>`. Assert returns empty dict.

3. `test_extract_formatting_from_element_paragraph_with_run` -- Pass a `<w:p>` element containing a `<w:r>` with formatting. Assert formatting is extracted from the run's rPr.

4. `test_extract_formatting_from_element_importable_from_xml_utils` -- Confirm `from src.xml_utils import extract_formatting_from_element` works (import test).

Import `extract_formatting_from_element` from `src.xml_formatting` (direct) and `extract_formatting` from `src.xml_utils` (barrel). Use `lxml.etree.fromstring` or the internal `_parse_element_xml` helper to create test elements.
  </action>
  <verify>
Run `python -m pytest tests/test_xml_utils.py -x -q -v` -- new tests pass. Then run full suite `python -m pytest tests/ -x -q` -- still 234+ tests pass (234 original + new ones).
  </verify>
  <done>
4 new tests confirm extract_formatting_from_element works correctly, matches the string-based version, handles edge cases, and is importable from the barrel module. Total test count increased.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -x -q` -- all tests pass (234 original + new parity tests)
2. `python -c "from src.models import AnswerPayload; a = AnswerPayload(pair_id='q1', xpath='/x', insertion_xml='<w:r/>', mode='replace_content'); print(a.answer_text, a.insertion_xml)"` prints `None <w:r/>`
3. `python -c "from src.models import AnswerPayload; a = AnswerPayload(pair_id='q1', xpath='/x', answer_text='hello', mode='replace_content'); print(a.answer_text, a.insertion_xml)"` prints `hello None`
4. `python -c "from src.xml_utils import extract_formatting_from_element; print('ok')"` prints `ok`
</verification>

<success_criteria>
- AnswerPayload model accepts answer_text alongside insertion_xml, both optional with None defaults
- extract_formatting_from_element is a public function returning formatting dicts from parsed elements
- extract_formatting delegates to extract_formatting_from_element (single code path)
- xml_utils.py re-exports the new function
- All 234 existing tests pass unchanged (backward compatibility)
- New parity tests confirm the element-based and string-based paths produce identical results
</success_criteria>

<output>
After completion, create `.planning/phases/05-fast-path-foundation/05-01-SUMMARY.md`
</output>
