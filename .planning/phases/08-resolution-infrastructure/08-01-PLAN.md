---
phase: 08-resolution-infrastructure
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/pair_id_resolver.py
  - src/models.py
  - tests/test_pair_id_resolver.py
autonomous: true
requirements:
  - ERG-03
  - ERG-04
  - ERG-05

must_haves:
  truths:
    - "resolve_pair_ids returns a dict mapping pair_id to xpath for all three file types"
    - "resolve_pair_ids returns empty dict for pair_ids not found in the document"
    - "cross_check_xpaths returns warning strings when agent-provided xpath differs from resolved xpath"
    - "cross_check_xpaths returns empty list when xpaths match or when only one is provided"
    - "AnswerPayload accepts xpath=None and mode=None without validation error"
  artifacts:
    - path: "src/pair_id_resolver.py"
      provides: "pair_id resolution and cross-check functions"
      exports: ["resolve_pair_ids", "cross_check_xpaths"]
    - path: "src/models.py"
      provides: "AnswerPayload with optional xpath and mode"
      contains: "xpath: str | None = None"
    - path: "tests/test_pair_id_resolver.py"
      provides: "Tests for resolver and cross-check"
      min_lines: 40
  key_links:
    - from: "src/pair_id_resolver.py"
      to: "src/handlers/word_indexer.py"
      via: "import extract_structure_compact"
      pattern: "word_indexer\\.extract_structure_compact"
    - from: "src/pair_id_resolver.py"
      to: "src/handlers/excel_indexer.py"
      via: "import extract_structure_compact"
      pattern: "excel_indexer\\.extract_structure_compact"
    - from: "src/pair_id_resolver.py"
      to: "src/handlers/pdf_indexer.py"
      via: "import extract_structure_compact"
      pattern: "pdf_indexer\\.extract_structure_compact"
---

<objective>
Create the pair_id resolution module and make AnswerPayload fields optional.

Purpose: Foundation for Phase 8 -- the resolver module encapsulates all pair_id-to-xpath
resolution logic, and the model changes allow xpath/mode to be omitted when answer_text
is provided. These are prerequisite for Plan 02 which wires them into the write path.

Output: `src/pair_id_resolver.py` with `resolve_pair_ids()` and `cross_check_xpaths()`,
updated `AnswerPayload` model, and tests proving correctness.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-resolution-infrastructure/08-RESEARCH.md
@src/models.py
@src/handlers/word_indexer.py
@src/handlers/excel_indexer.py
@src/handlers/pdf_indexer.py
@src/handlers/word_location_validator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pair_id_resolver.py with resolve and cross-check functions</name>
  <files>src/pair_id_resolver.py, tests/test_pair_id_resolver.py</files>
  <action>
Create `src/pair_id_resolver.py` (~50 lines) with two public functions:

1. `resolve_pair_ids(file_bytes: bytes, file_type: FileType, pair_ids: list[str]) -> dict[str, str]`
   - For WORD: import `extract_structure_compact` from `src.handlers.word_indexer`, call it, return `{pid: compact.id_to_xpath[pid] for pid in pair_ids if pid in compact.id_to_xpath}`
   - For EXCEL: import `extract_structure_compact` from `src.handlers.excel_indexer`, same pattern
   - For PDF: import `extract_structure_compact` from `src.handlers.pdf_indexer`, same pattern
   - Use lazy imports (inside function body) to avoid circular imports and unnecessary loading
   - Return empty dict for unknown file types
   - Omit pair_ids not found in the mapping (caller checks for missing)

2. `cross_check_xpaths(answers: list[dict], resolved: dict[str, str]) -> list[str]`
   - Iterate answers. For each answer that has BOTH `xpath` and `pair_id`:
     - Look up resolved xpath from `resolved` dict
     - If both agent xpath and resolved xpath exist and differ, append warning string:
       `"pair_id '{pair_id}': agent xpath '{agent_xpath}' differs from resolved xpath '{resolved_xpath}' -- using resolved (pair_id is authority)"`
   - Return list of warning strings (empty if no mismatches)

Add module docstring explaining: this module resolves pair_ids to xpaths via re-extraction
of the compact structure. It is called from tool_errors.py during payload construction
when xpath is not provided. The resolution reuses the same extract_structure_compact()
functions used by the extraction tools.

Create `tests/test_pair_id_resolver.py` with TDD tests:
- RED: Write tests for resolve_pair_ids with Word fixture (table_questionnaire.docx) -- resolve known pair_ids (T1-R2-C2), verify returned xpaths match id_to_xpath from compact extraction
- RED: Write test for resolve_pair_ids with unknown pair_id -- verify it is omitted from result
- RED: Write test for cross_check_xpaths with matching xpaths -- verify empty warnings
- RED: Write test for cross_check_xpaths with mismatching xpaths -- verify warning string
- RED: Write test for cross_check_xpaths when only pair_id provided (no agent xpath) -- verify no warning
- GREEN: Implement the functions to pass all tests

Use existing fixtures from tests/fixtures/ (table_questionnaire.docx, vendor_assessment.xlsx, simple_form.pdf).
  </action>
  <verify>
`cd /home/sarturko/vibe-legal-form-filler && python -m pytest tests/test_pair_id_resolver.py -v` -- all tests pass.
`cd /home/sarturko/vibe-legal-form-filler && python -m pytest tests/ -v` -- all 281+ existing tests still pass.
  </verify>
  <done>
resolve_pair_ids returns correct xpaths for Word/Excel/PDF pair_ids, omits unknown pair_ids.
cross_check_xpaths produces warnings only when both xpath and pair_id are provided and they disagree.
All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make xpath and mode optional on AnswerPayload</name>
  <files>src/models.py</files>
  <action>
In `src/models.py`, update the `AnswerPayload` class:

1. Change `xpath: str` to `xpath: str | None = None`
2. Change `mode: InsertionMode` to `mode: InsertionMode | None = None`

These changes make both fields optional at the Pydantic model level. The validation
of when they are required (insertion_xml path needs explicit xpath and mode) is
handled in tool_errors.py (Plan 02).

Do NOT change any other model. The AnswerPayload change is purely additive --
existing code that always provides xpath and mode will continue to work because
the fields still accept str and InsertionMode values.

Verify that models.py stays at or under 200 lines.
  </action>
  <verify>
`cd /home/sarturko/vibe-legal-form-filler && python -m pytest tests/ -v` -- all existing tests pass.
`wc -l src/models.py` -- at or under 200 lines.
`python -c "from src.models import AnswerPayload; p = AnswerPayload(pair_id='q1'); print(p.xpath, p.mode)"` -- prints `None None` confirming optionality.
  </verify>
  <done>
AnswerPayload accepts xpath=None and mode=None without error.
All existing tests pass (they still provide both fields explicitly).
models.py is at or under 200 lines.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_pair_id_resolver.py -v` -- new resolver tests pass
2. `python -m pytest tests/ -v` -- all 281+ tests pass (no regressions)
3. `wc -l src/pair_id_resolver.py` -- under 60 lines
4. `wc -l src/models.py` -- at or under 200 lines
5. `python -c "from src.pair_id_resolver import resolve_pair_ids, cross_check_xpaths; print('imports ok')"` -- module imports cleanly
</verification>

<success_criteria>
- pair_id_resolver.py exists with resolve_pair_ids and cross_check_xpaths
- AnswerPayload.xpath and AnswerPayload.mode are both Optional with None defaults
- All existing tests pass without modification
- New resolver tests pass for Word, Excel, PDF resolution and cross-check logic
</success_criteria>

<output>
After completion, create `.planning/phases/08-resolution-infrastructure/08-01-SUMMARY.md`
</output>
