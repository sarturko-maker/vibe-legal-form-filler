---
phase: 10-verification-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models.py
  - src/tool_errors.py
  - src/tools_write.py
  - tests/test_resolution.py
autonomous: true
requirements: [VER-01, VER-02]

must_haves:
  truths:
    - "Agent can call verify_output with pair_id and expected_text only (no xpath) and get a correct verification report"
    - "When both xpath and pair_id are provided, cross-check warns on mismatch and uses resolved xpath"
    - "verify_output response includes resolved_from metadata per content_result"
    - "Existing verify_output calls with explicit xpath still work unchanged"
  artifacts:
    - path: "src/models.py"
      provides: "Optional xpath on ExpectedAnswer, resolved_from on ContentResult"
      contains: "xpath: str | None = None"
    - path: "src/tool_errors.py"
      provides: "Resolution-aware validate_expected_answers"
      contains: "def validate_expected_answers"
    - path: "src/tools_write.py"
      provides: "verify_output wired to pass file_bytes and inject metadata"
      contains: "validate_expected_answers(expected_answers, ft, raw)"
    - path: "tests/test_resolution.py"
      provides: "E2E tests for pair_id-only verify_output"
      contains: "class TestPairIdOnlyVerify"
  key_links:
    - from: "src/tools_write.py"
      to: "src/tool_errors.py"
      via: "validate_expected_answers(expected_answers, ft, raw)"
      pattern: "answers, warnings, resolved_from_list = validate_expected_answers"
    - from: "src/tool_errors.py"
      to: "src/pair_id_resolver.py"
      via: "resolve_pair_ids and cross_check_xpaths imports"
      pattern: "from src.pair_id_resolver import"
---

<objective>
Add pair_id resolution to verify_output, matching the write_answers capability built in Phase 8.

Purpose: Agents currently must carry xpaths through the entire pipeline to call verify_output. After this plan, agents can verify with just `{pair_id, expected_text}` -- the server resolves the xpath automatically using the same infrastructure from Phase 8.

Output: Updated models, validation, tool function, and E2E tests proving pair_id-only verification works for Word/Excel/PDF.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-verification-parity/10-RESEARCH.md
@src/models.py
@src/tool_errors.py
@src/tools_write.py
@src/pair_id_resolver.py
@tests/test_resolution.py
@tests/test_word_verifier.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Model changes and resolution-aware validation</name>
  <files>
    src/models.py
    src/tool_errors.py
  </files>
  <action>
**models.py changes:**

1. Make `ExpectedAnswer.xpath` optional:
   ```python
   class ExpectedAnswer(BaseModel):
       pair_id: str
       xpath: str | None = None    # optional when pair_id is provided
       expected_text: str
       confidence: Confidence = Confidence.KNOWN
   ```

2. Add `resolved_from` to `ContentResult`:
   ```python
   class ContentResult(BaseModel):
       pair_id: str
       status: ContentStatus
       expected: str
       actual: str
       resolved_from: str | None = None  # "pair_id" or "xpath" or None
   ```

**tool_errors.py changes:**

1. Remove `"xpath"` from `_EXPECTED_REQUIRED`. Change to:
   ```python
   _EXPECTED_REQUIRED = ("pair_id", "expected_text")
   ```

2. Update the `validate_expected_answers` signature to accept `ft` and `file_bytes` and return a 3-tuple:
   ```python
   def validate_expected_answers(
       expected_answers: list[dict],
       ft: FileType | None = None,
       file_bytes: bytes | None = None,
   ) -> tuple[list[ExpectedAnswer], list[str], list[str | None]]:
   ```
   Returns `(answers, warnings, resolved_from_list)`.

3. Inside `validate_expected_answers`, add resolution logic AFTER the required-field check:
   - Check if any answers need resolution (`not a.get("xpath") and a.get("pair_id")`) or cross-check (`a.get("xpath") and a.get("pair_id")`).
   - If resolution/cross-check is needed AND `file_bytes` and `ft` are provided:
     - For `FileType.EXCEL` or `FileType.PDF`: relaxed path -- `resolved = {pid: pid for pid in pair_ids}`. No cross-check (per decision 08-02).
     - For `FileType.WORD`: call `resolve_pair_ids(file_bytes, ft, pair_ids)` and `cross_check_xpaths(answers, resolved)`.
   - For each answer dict, determine xpath and resolved_from:
     - If no xpath and has pair_id: use `resolved.get(pair_id)`. Set `resolved_from = "pair_id"`. If not found in resolved and ft is EXCEL/PDF, use pair_id directly (identity fallback). If still no xpath, raise ValueError with clear message.
     - If xpath provided and pair_id in resolved and they differ: use resolved xpath (pair_id is authority). Set `resolved_from = "pair_id"`.
     - If xpath provided and no mismatch: set `resolved_from = "xpath"`.
   - Build ExpectedAnswer with the resolved xpath and track resolved_from in a parallel list.

4. When `ft` and `file_bytes` are both None (backward-compatible call), behave identically to current: xpath is required (raise error if missing), no resolution, return empty warnings and all-None resolved_from_list.

5. Update the USAGE example for verify_output to show pair_id-only:
   ```python
   "verify_output": (
       'verify_output(file_path="filled.docx", expected_answers=[{"pair_id": '
       '"q1", "expected_text": "Acme Corp"}])'
   ),
   ```

6. Update the error messages to say `"Required: pair_id (str), expected_text (str)"` and `"Optional: xpath (str), confidence (str, default 'known')"`.

**Import `resolve_pair_ids` and `cross_check_xpaths` lazily** inside the function body (same pattern as `_resolve_if_needed`), not at module top level.
  </action>
  <verify>
Run `python -m pytest tests/test_word_verifier.py tests/test_pair_id_resolver.py tests/test_e2e_integration.py -v` -- all existing tests must pass. The model changes (Optional xpath, new resolved_from field) are additive and backward compatible. The validate_expected_answers signature change returns a tuple now, but the caller in tools_write.py will be updated in Task 2.
  </verify>
  <done>
ExpectedAnswer.xpath is Optional[str] = None. ContentResult has resolved_from field. validate_expected_answers accepts ft+file_bytes, returns 3-tuple, resolves pair_ids for Word via re-extraction, uses identity mapping for Excel/PDF, cross-checks on Word path only. Error messages updated. USAGE example updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire resolution into verify_output and add E2E tests</name>
  <files>
    src/tools_write.py
    tests/test_resolution.py
  </files>
  <action>
**tools_write.py changes:**

1. Update `verify_output` to pass `ft` and `raw` to `validate_expected_answers` and unpack the 3-tuple:
   ```python
   answers, warnings, resolved_from_list = validate_expected_answers(
       expected_answers, ft, raw
   )
   ```

2. After the handler verifier returns the result dict (via `.model_dump()`), inject `resolved_from` into each `content_results` entry from the parallel list:
   ```python
   for i, rf in enumerate(resolved_from_list):
       if i < len(result["content_results"]):
           result["content_results"][i]["resolved_from"] = rf
   ```

3. If `warnings` is non-empty, add to response dict:
   ```python
   if warnings:
       result["warnings"] = warnings
   ```

4. Update the docstring of `verify_output` to document that xpath is optional when pair_id is provided:
   ```
   expected_answers: list of {pair_id, expected_text} dicts. xpath is optional --
       when omitted, the server resolves it from pair_id via re-extraction.
       When both xpath and pair_id are provided, the server cross-checks and
       warns on mismatch (pair_id takes precedence).
   ```

**tests/test_resolution.py changes:**

Add a new test class `TestPairIdOnlyVerify` with these tests:

1. `test_verify_output_pair_id_only_word` -- Write an answer to a Word doc using pair_id-only write_answers, then verify with pair_id-only verify_output. Assert all content matched, resolved_from is "pair_id" on each content_result.

2. `test_verify_output_pair_id_only_excel` -- Write an answer to an Excel doc, then verify with pair_id-only verify_output. Assert matched, resolved_from is "pair_id".

3. `test_verify_output_cross_check_warning` -- Call verify_output with a wrong xpath and correct pair_id on a filled Word doc. Assert warnings list is non-empty, assert the answer still verifies correctly (resolved xpath used), and resolved_from is "pair_id".

4. `test_verify_output_backward_compatible` -- Call verify_output with explicit xpath (the old way) on a filled Word doc. Assert it still works. Assert resolved_from is "xpath" on content_results.

5. `test_verify_output_pair_id_not_found` -- Call verify_output with a non-existent pair_id (no xpath) on a Word doc. Assert ValueError with "could not be resolved" message.

All tests should use the `server.verify_output` and `server.write_answers` imports (same pattern as existing `TestPairIdOnlyWrite` class). Use `docx_path` and `xlsx_path` fixtures already defined in the file.
  </action>
  <verify>
Run `python -m pytest tests/ -v` -- all tests must pass including the 5 new ones. Expected total: ~311+ tests (306 existing + 5 new). Specifically run `python -m pytest tests/test_resolution.py -v` to confirm all new tests pass.
  </verify>
  <done>
verify_output wired to pass file_bytes for resolution. resolved_from injected into each content_result. warnings attached to response when present. 5 new E2E tests pass covering pair_id-only Word, pair_id-only Excel, cross-check warning, backward compatibility, and unresolvable pair_id error.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- all tests pass (existing + 5 new)
2. Manual check: `ExpectedAnswer.xpath` is `str | None = None` in models.py
3. Manual check: `ContentResult.resolved_from` is `str | None = None` in models.py
4. Manual check: `validate_expected_answers` returns 3-tuple `(answers, warnings, resolved_from_list)`
5. Manual check: `verify_output` in tools_write.py unpacks the 3-tuple and injects metadata
6. Manual check: No handler verifiers (word_verifier.py, excel_verifier.py, pdf_verifier.py) were modified
</verification>

<success_criteria>
- Agent can call verify_output with `{pair_id: "T1-R2-C2", expected_text: "Acme Corp"}` (no xpath) and get correct verification
- Cross-check warns when both xpath and pair_id provided and they disagree
- Each content_result in the response has a `resolved_from` field ("pair_id", "xpath", or null)
- All existing tests pass unchanged (backward compatible)
- 5 new E2E tests prove the feature works for Word, Excel, cross-check, backward compat, and error cases
</success_criteria>

<output>
After completion, create `.planning/phases/10-verification-parity/10-01-SUMMARY.md`
</output>
