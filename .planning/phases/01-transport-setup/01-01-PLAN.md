---
phase: 01-transport-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/http_transport.py
  - src/server.py
  - src/__main__.py
  - pyproject.toml
autonomous: true
requirements:
  - TRANS-01
  - TRANS-02
  - TRANS-07

must_haves:
  truths:
    - "Running `mcp-form-filler` (no args) starts the server in stdio mode exactly as before"
    - "Running `mcp-form-filler --transport http` starts the server bound to 127.0.0.1:8000"
    - "Running `mcp-form-filler --transport http --port 9000` binds to port 9000"
    - "`--port` or `--host` without `--transport http` prints an error and exits non-zero"
    - "All 172 existing unit tests pass without modification"
    - "All 6 MCP tools are registered and available in both transport modes"
  artifacts:
    - path: "src/http_transport.py"
      provides: "Port availability check and custom uvicorn HTTP runner with graceful shutdown"
      min_lines: 40
    - path: "src/server.py"
      provides: "CLI argument parsing with argparse, env var fallbacks, transport dispatch"
      contains: "def main"
    - path: "src/__main__.py"
      provides: "Package-level entry point for python -m src"
      contains: "from src.server import main"
    - path: "pyproject.toml"
      provides: "console_scripts entry point for mcp-form-filler"
      contains: "mcp-form-filler"
  key_links:
    - from: "src/server.py"
      to: "src/http_transport.py"
      via: "import start_http, call for HTTP dispatch"
      pattern: "from src\\.http_transport import start_http"
    - from: "src/server.py"
      to: "src/mcp_app.py"
      via: "import mcp instance, modify settings before dispatch"
      pattern: "mcp\\.settings\\.(host|port)"
    - from: "src/__main__.py"
      to: "src/server.py"
      via: "import and call main()"
      pattern: "from src\\.server import main"
    - from: "pyproject.toml"
      to: "src/server.py"
      via: "console_scripts entry point"
      pattern: 'mcp-form-filler = "src.server:main"'
---

<objective>
Add HTTP transport mode alongside existing stdio so the server can be started in either mode via a `--transport {stdio,http}` flag. Implement CLI argument parsing, port conflict detection, custom uvicorn runner with graceful shutdown, and console_scripts entry point.

Purpose: Enable the MCP server to accept HTTP connections from cross-platform AI agents (Gemini CLI, Antigravity) while preserving the existing stdio transport for Claude Code.

Output: Four files — `src/http_transport.py` (new), `src/server.py` (modified), `src/__main__.py` (new), `pyproject.toml` (modified) — plus verified passing test suite.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-transport-setup/01-RESEARCH.md
@src/server.py
@src/mcp_app.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTTP transport runner</name>
  <files>src/http_transport.py</files>
  <action>
Create `src/http_transport.py` — the HTTP startup module. This file contains port conflict detection and a custom uvicorn runner with graceful shutdown. It must stay under 200 lines (project convention).

Implement these functions:

1. `check_port_available(host: str, port: int) -> bool`
   - Create a TCP socket, attempt `sock.bind((host, port))`.
   - Return `True` if bind succeeds, `False` if `OSError` with `errno.EADDRINUSE`.
   - Re-raise any other `OSError`.
   - Always close socket in `finally`.

2. `_run_http_async(host: str, port: int) -> None` (async)
   - Call `mcp.streamable_http_app()` to get the Starlette app.
   - Create `uvicorn.Config(starlette_app, host=host, port=port, log_level=mcp.settings.log_level.lower(), timeout_graceful_shutdown=GRACEFUL_SHUTDOWN_TIMEOUT)`.
   - Create `uvicorn.Server(config)` and `await server.serve()`.

3. `start_http(host: str, port: int) -> None`
   - Call `check_port_available(host, port)`. If False, print to stderr: `Error: Port {port} is already in use. Try: --port {port + 1}` and `sys.exit(1)`.
   - Otherwise call `anyio.run(_run_http_async, host, port)`.

Module-level constant: `GRACEFUL_SHUTDOWN_TIMEOUT = 5` (seconds).

Imports: `anyio`, `errno`, `socket`, `sys`, `uvicorn`, and `from src.mcp_app import mcp`.

Add module docstring explaining what this file does and why it exists (port pre-checking and graceful shutdown not provided by `mcp.run()` directly).

Add AGPL-3.0 license header matching other source files.
  </action>
  <verify>
File exists at `src/http_transport.py`, is under 200 lines, contains all three functions. Run `python -c "from src.http_transport import start_http, check_port_available"` to confirm importability.
  </verify>
  <done>
`src/http_transport.py` exists with `check_port_available()`, `_run_http_async()`, and `start_http()` functions. Module imports cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI parsing and transport dispatch to server.py</name>
  <files>src/server.py, src/__main__.py, pyproject.toml</files>
  <action>
**server.py** — Refactor to add CLI parsing and transport dispatch. Preserve existing import structure (tool registration happens at import time via the existing `from src.tools_extract import ...` and `from src.tools_write import ...` lines). These imports MUST remain at module level so tools are registered before any transport dispatch.

Add these functions:

1. `_validate_port(value: str) -> int`
   - Convert to int. Reject if outside 1024-65535 with `argparse.ArgumentTypeError`.
   - Message: `"Port must be between 1024 and 65535, got {port}"`.

2. `_build_parser() -> argparse.ArgumentParser`
   - `prog="mcp-form-filler"`.
   - `description="MCP server exposing form-filling tools for copilot agents"`.
   - `epilog` with usage examples (use `RawDescriptionHelpFormatter`):
     ```
     Examples:
       mcp-form-filler                              # stdio (default)
       mcp-form-filler --transport http              # HTTP on 127.0.0.1:8000
       mcp-form-filler --transport http --port 9000  # HTTP on custom port
     ```
   - `--transport` flag: `choices=["stdio", "http"]`, default from `MCP_FORM_FILLER_TRANSPORT` env var (fallback `"stdio"`).
   - `--port` flag: `type=_validate_port`, `default=None`. Help mentions default 8000 and env var `MCP_FORM_FILLER_PORT`.
   - `--host` flag: `default=None`. Help mentions default 127.0.0.1 and env var `MCP_FORM_FILLER_HOST`.

3. `_resolve_args(args: argparse.Namespace) -> argparse.Namespace`
   - Post-parse validation and env var resolution for `--port` and `--host`.
   - If `args.transport != "http"` but `args.port` or `args.host` was explicitly set (not None): print error `"Error: --port and --host require --transport http"` to stderr and `sys.exit(2)`.
   - If `args.transport == "http"`:
     - Resolve port: `args.port` if set, else `int(os.environ.get("MCP_FORM_FILLER_PORT", "8000"))`. Validate range 1024-65535 (catch ValueError for non-numeric env var).
     - Resolve host: `args.host` if set, else `os.environ.get("MCP_FORM_FILLER_HOST", "127.0.0.1")`.
   - Return modified args.

4. `main() -> None`
   - Call `_build_parser().parse_args()`, then `_resolve_args()`.
   - If `args.transport == "stdio"`: call `mcp.run()` (exact same as current behavior).
   - If `args.transport == "http"`:
     - Set `mcp.settings.host = args.host` and `mcp.settings.port = args.port` BEFORE calling HTTP startup (so DNS rebinding protection configures for the correct host).
     - Import and call `from src.http_transport import start_http; start_http(args.host, args.port)`.

5. Replace `if __name__ == "__main__": mcp.run()` with `if __name__ == "__main__": main()`.

Keep all existing tool re-exports (`from src.tools_extract import ...`, `from src.tools_write import ...`) unchanged.

New imports needed at top: `argparse`, `os`, `sys`.

The file must stay under 200 lines. The existing file is ~44 lines; the additions are ~80-100 lines of argparse/validation/dispatch logic. Total ~130 lines — well under limit.

**src/__main__.py** — Create new file enabling `python -m src` invocation.
- AGPL-3.0 license header.
- Module docstring: `"Allow running as python -m src."`
- Body: `from src.server import main` then `main()`.

**pyproject.toml** — Add console_scripts entry point.
- Add `[project.scripts]` section after `[project.optional-dependencies]`:
  ```toml
  [project.scripts]
  mcp-form-filler = "src.server:main"
  ```
  </action>
  <verify>
1. `python -c "from src.server import main; print('OK')"` succeeds.
2. `python -m src.server --help` shows all three flags with usage examples and env var documentation.
3. `python -m src.server --port 9000` (without --transport http) exits non-zero with error message.
4. `python -m src.server --transport stdio` starts normally (Ctrl+C to exit).
5. `python -m src.server --transport http` starts HTTP server on 127.0.0.1:8000 (Ctrl+C to exit).
6. Check `python -m src --help` works via __main__.py.
  </verify>
  <done>
`server.py` contains `main()` with argparse CLI parsing, env var fallbacks, cross-flag validation, and transport dispatch. `__main__.py` exists for package invocation. `pyproject.toml` has `mcp-form-filler` console_scripts entry. Both `python -m src.server --help` and `python -m src --help` work. `--port` without `--transport http` is rejected.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify all existing tests pass and tool registration works</name>
  <files></files>
  <action>
Run the full existing test suite to confirm TRANS-07 (stdio transport continues working exactly as before). No test files should need modification — this is a regression check.

1. Run `pytest tests/ -v` from the project root. All 172 tests must pass.
2. Verify tool registration parity by running a quick Python check:
   ```python
   from src.server import mcp
   tools = mcp.list_tools()
   # Should list all 6 tools + 2 utilities
   ```
   If `list_tools()` is async, use `asyncio.run()`.
3. If any test fails, investigate whether the failure is caused by the server.py changes. The only change to server.py's module-level behavior is adding imports (`argparse`, `os`, `sys`) and function definitions — these should not affect any test that imports from `src.server`.

**Do NOT modify any test files.** If tests fail due to our changes, fix the source files instead.
  </action>
  <verify>
`pytest tests/ -v` output shows all tests passing. Zero failures, zero errors.
  </verify>
  <done>
All 172 existing tests pass. Tool registration confirmed identical in both modes. TRANS-07 (stdio unchanged) is validated.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -v` — all 172 tests pass (TRANS-07)
2. `python -m src.server --help` — shows --transport, --port, --host with defaults and env vars
3. `python -m src.server --transport http &` then `curl http://127.0.0.1:8000/` — server responds (TRANS-01, TRANS-02)
4. `python -m src.server --port 9000` — exits with error about requiring --transport http
5. `python -m src --help` — works via __main__.py
6. `MCP_FORM_FILLER_TRANSPORT=http MCP_FORM_FILLER_PORT=9000 python -m src.server` — starts on port 9000
</verification>

<success_criteria>
- Server starts in stdio mode by default (backward compatible, no behavioral changes)
- Server starts in HTTP mode with `--transport http`, binding to 127.0.0.1:8000
- Port conflict detection prints clear error and exits non-zero
- `--port`/`--host` rejected when `--transport` is not `http`
- Environment variable fallbacks work for all three flags
- All 172 existing tests pass without modification
- Both `python -m src.server` and `python -m src` entry points work
- `pyproject.toml` has `mcp-form-filler` console_scripts entry
</success_criteria>

<output>
After completion, create `.planning/phases/01-transport-setup/01-01-SUMMARY.md`
</output>
