---
phase: 03-http-integration-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/conftest.py
  - tests/test_http_protocol.py
  - tests/test_http_transport_parity.py
autonomous: true
requirements: [TEST-01, TEST-02]

must_haves:
  truths:
    - "All 217 existing tests pass without modification after Phase 3 changes"
    - "extract_structure_compact returns identical JSON when called directly vs over HTTP"
    - "extract_structure returns identical output when called directly vs over HTTP"
    - "validate_locations returns identical output when called directly vs over HTTP"
    - "build_insertion_xml returns identical output when called directly vs over HTTP"
    - "write_answers returns identical output when called directly vs over HTTP"
    - "verify_output returns identical output when called directly vs over HTTP"
  artifacts:
    - path: "tests/conftest.py"
      provides: "Shared MCP session fixture, SSE parser, tool call helper"
      min_lines: 50
    - path: "tests/test_http_transport_parity.py"
      provides: "Transport parity tests for all 6 core MCP tools"
      min_lines: 80
  key_links:
    - from: "tests/conftest.py"
      to: "src/mcp_app.py"
      via: "mcp_session fixture creates TestClient from mcp.streamable_http_app()"
      pattern: "mcp\\.streamable_http_app"
    - from: "tests/test_http_transport_parity.py"
      to: "tests/conftest.py"
      via: "uses mcp_session fixture and parse_tool_result/call_tool helpers"
      pattern: "mcp_session|parse_tool_result|call_tool"
    - from: "tests/test_http_transport_parity.py"
      to: "src/tools_extract.py"
      via: "imports tool functions for direct-call baseline comparison"
      pattern: "from src\\.tools_extract import"
---

<objective>
Create shared HTTP test infrastructure (conftest.py) and transport parity tests proving all 6 core MCP tools return identical results over HTTP vs direct calls.

Purpose: Establish the test foundation that all Phase 3 HTTP tests will use, and prove the core transport parity guarantee — the project's central value proposition.
Output: conftest.py with shared fixtures/helpers, refactored test_http_protocol.py using shared fixtures, test_http_transport_parity.py with 6 parity tests.
</objective>

<execution_context>
@/home/sarturko/.claude/get-shit-done/workflows/execute-plan.md
@/home/sarturko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-http-integration-testing/03-RESEARCH.md
@.planning/phases/02-protocol-implementation/02-01-SUMMARY.md
@tests/test_http_protocol.py
@src/tools_extract.py
@src/tools_write.py
@src/mcp_app.py
@src/http_transport.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conftest.py with shared HTTP fixtures and refactor test_http_protocol.py</name>
  <files>tests/conftest.py, tests/test_http_protocol.py</files>
  <action>
Create `tests/conftest.py` with these shared components:

1. **Constants** (moved from test_http_protocol.py):
   - `INIT_BODY` — JSON-RPC initialize body with protocolVersion "2025-03-26"
   - `MCP_HEADERS` — Content-Type + Accept headers for MCP requests

2. **Helper: `_fresh_app()`** — Resets `mcp._session_manager = None`, builds app via `mcp.streamable_http_app()`, attaches `_json_rpc_404_handler` to `exception_handlers[404]`, returns app.

3. **Fixture: `_reset_session_manager` (autouse=True)** — Yields, then sets `mcp._session_manager = None` on cleanup.

4. **Fixture: `mcp_session`** — Creates TestClient with `_fresh_app()`, `raise_server_exceptions=False`, `headers={"Host": "localhost:8000"}`. Sends initialize request, captures `mcp-session-id` from response headers. Sends `notifications/initialized` notification. Yields `(client, session_headers)` tuple where `session_headers` includes Content-Type, Accept, and Mcp-Session-Id.

5. **Helper: `call_tool(client, headers, tool_name, arguments, request_id=99)`** — Builds JSON-RPC `tools/call` body and sends POST to `/mcp`.

6. **Helper: `parse_tool_result(response) -> dict`** — Parses SSE response text, finds `data:` line with `result` key, extracts `result.content[0].text`, parses as JSON, returns dict. Raises `ValueError` if no result found.

Imports needed: `pytest`, `json`, `starlette.testclient.TestClient`, `src.mcp_app.mcp`, `src.http_transport._json_rpc_404_handler`, plus `import src.tools_extract` and `import src.tools_write` (noqa: F401) for tool registration.

Then refactor `tests/test_http_protocol.py`:
- Remove `INIT_BODY`, `MCP_HEADERS`, `_fresh_app()`, `_reset_session_manager` (now in conftest.py)
- Remove `import src.tools_extract` and `import src.tools_write` (now in conftest.py)
- Keep the `from starlette.testclient import TestClient` import (needed for test_invalid_origin_returns_403 which creates its own TestClient)
- Keep `from src.http_transport import _json_rpc_404_handler` and `from src.mcp_app import mcp` (needed for test_invalid_origin_returns_403's inline `_fresh_app()` call — since it can NOT use the shared fixture, it needs its own fresh app)
- Rename `mcp_client` fixture to use `mcp_session` from conftest.py instead. Update all test functions that used `mcp_client` to use `mcp_session` and unpack `(client, headers)`.
- For `test_invalid_origin_returns_403`: keep it creating its own fresh TestClient inline (per Phase 2 decision — invalid origin test needs its own client since the mcp_session fixture would fail during init handshake with a blocked origin). It needs to call `_fresh_app()` locally since it can NOT use the conftest fixture.

The refactored test_http_protocol.py should be shorter than the current 189 lines since boilerplate is extracted.

Include the AGPL license header in conftest.py matching the style in test_http_protocol.py.
  </action>
  <verify>
Run `pytest tests/ -x -q` — all 217 tests must pass. Run `wc -l tests/conftest.py tests/test_http_protocol.py` — conftest.py under 100 lines, test_http_protocol.py under 160 lines, neither over 200.
  </verify>
  <done>
conftest.py exists with mcp_session fixture, call_tool helper, and parse_tool_result helper. test_http_protocol.py uses shared fixtures from conftest.py. All 217 existing tests pass. Both files under 200 lines.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write transport parity tests for all 6 core MCP tools</name>
  <files>tests/test_http_transport_parity.py</files>
  <action>
Create `tests/test_http_transport_parity.py` with 6 transport parity tests — one per core MCP tool. Each test calls the tool over HTTP (via mcp_session fixture + call_tool + parse_tool_result) AND directly (importing the function from src.tools_extract or src.tools_write), then asserts the results are identical.

Include the AGPL license header.

**Test 1: `test_extract_structure_compact_parity(mcp_session)`**
- Args: `{"file_path": "tests/fixtures/table_questionnaire.docx"}`
- HTTP: call_tool → parse_tool_result → http_result
- Direct: `from src.tools_extract import extract_structure_compact; direct = extract_structure_compact(file_path="tests/fixtures/table_questionnaire.docx")`
- Assert: `http_result == direct`

**Test 2: `test_extract_structure_parity(mcp_session)`**
- Args: `{"file_path": "tests/fixtures/table_questionnaire.docx"}`
- HTTP: call_tool("extract_structure", args) → parse_tool_result
- Direct: `from src.tools_extract import extract_structure; direct = extract_structure(file_path="tests/fixtures/table_questionnaire.docx")`
- Assert: `http_result == direct`

**Test 3: `test_validate_locations_parity(mcp_session)`**
- First extract compact to get valid IDs: `from src.tools_extract import extract_structure_compact; compact = extract_structure_compact(file_path="tests/fixtures/table_questionnaire.docx")`
- Pick 2 valid element IDs from `compact["id_to_xpath"]` (e.g. first 2 keys)
- Build locations list: `[{"pair_id": "q1", "location": id1}, {"pair_id": "q2", "location": id2}]`
- Args: `{"file_path": "tests/fixtures/table_questionnaire.docx", "locations": locations}`
- HTTP vs direct, assert equal

**Test 4: `test_build_insertion_xml_parity(mcp_session)`**
- First get target context: extract structure, pick a valid XPath from id_to_xpath
- Use extract_structure to get body XML, extract a small context snippet around the target
- Args: `{"answer_text": "Test Answer", "target_context_xml": context_snippet, "answer_type": "plain_text"}`
- HTTP vs direct, assert equal

**Test 5: `test_write_answers_parity(mcp_session, tmp_path)`**
- Build a minimal answer set: extract compact from table_questionnaire.docx, pick one empty cell ID, validate it, build insertion XML for a test answer
- Use `output_file_path` for both calls (write to tmp_path) to avoid base64 comparison
- HTTP args: `{"file_path": "tests/fixtures/table_questionnaire.docx", "answers": [answer_dict], "output_file_path": str(http_output)}`
- Direct args: same but `output_file_path` = str(direct_output)
- Compare: both return dicts with "file_path" key; read both output files as bytes and assert identical

**Test 6: `test_verify_output_parity(mcp_session)`**
- Use the filled document from the write_answers call OR build a simple expected_answers list
- Args: `{"file_path": "tests/fixtures/table_questionnaire.docx", "expected_answers": [{"pair_id": "q1", "xpath": xpath, "expected_text": "some text"}]}`
- HTTP vs direct, assert equal

**Important notes:**
- The write_answers parity test is the most complex. If getting all the setup correct within 200 lines is challenging, simplify: just compare the response dict structure (both paths return the same dict). The key guarantee is that the HTTP transport doesn't alter the function output.
- For build_insertion_xml, the `target_context_xml` needs to be valid OOXML context. Get it by reading the document XML at the target location. If this is too complex, use a minimal valid context like `<w:p><w:r><w:rPr><w:rFonts w:ascii="Calibri"/></w:rPr><w:t>placeholder</w:t></w:r></w:p>` (registered OOXML namespace).
- Direct function calls may return dicts directly or may need to be adapted. Check the actual tool function signatures — they use `file_path` parameter, same as the HTTP args.
- Keep the file under 200 lines. If close, move setup helpers to conftest.py.
  </action>
  <verify>
Run `pytest tests/test_http_transport_parity.py -v` — all 6 tests pass. Run `wc -l tests/test_http_transport_parity.py` — under 200 lines. Run `pytest tests/ -x -q` — all tests still pass (217 existing + 6 new = 223).
  </verify>
  <done>
6 transport parity tests pass, each proving the HTTP path returns identical results to the direct function call path. File under 200 lines. Total test suite grows to 223+ passing tests.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -x -q` — all tests pass (217 existing + 6+ new)
2. `wc -l tests/conftest.py tests/test_http_protocol.py tests/test_http_transport_parity.py` — all under 200 lines
3. Each of the 6 core tools has a parity test confirming HTTP == direct output
4. conftest.py provides reusable mcp_session, call_tool, parse_tool_result for Plan 2
</verification>

<success_criteria>
- conftest.py exists with shared HTTP test infrastructure
- test_http_protocol.py refactored to use shared fixtures, all 10 protocol tests still pass
- test_http_transport_parity.py has 6 passing parity tests (one per core MCP tool)
- All files under 200 lines
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-http-integration-testing/03-01-SUMMARY.md`
</output>
